# A_Ultra_Fast_Mathematician

## Platform

Codeforces

## Problem Link

[A. Ultra-Fast Mathematician](https://codeforces.com/problemset/problem/61/A)

## Problem Statement

The mathematician Xenia loves binary numbers. She has two binary numbers of equal length.

Xenia defines a new binary number by comparing the digits of the two numbers at each position:

* If the digits are the same, the resulting digit is `0`
* If the digits are different, the resulting digit is `1`

Your task is to compute and print the resulting binary number.

This operation is equivalent to a **bitwise XOR**, but it must be performed character by character on strings.

## Input Format

* The first line contains a binary string `a`
* The second line contains a binary string `b`

Both strings have the same length and consist only of characters `0` and `1`.

## Output Format

* Print a single binary string representing the result of the comparison.

## Constraints

* `1 ≤ length(a) = length(b) ≤ 100`
* Each character is either `'0'` or `'1'`

## Examples

### Example 1

Input

```
101010
010101
```

Explanation

Each position contains different digits, so all output digits become `1`.

Output

```
111111
```

---

### Example 2

Input

```
1110
1110
```

Explanation

All corresponding digits are equal, so all output digits become `0`.

Output

```
0000
```

---

### Example 3

Input

```
1001
0011
```

Explanation

```
1 vs 0 → 1
0 vs 0 → 0
0 vs 1 → 1
1 vs 1 → 0
```

Output

```
1010
```

## Approach

**Character-wise XOR simulation using string traversal**

## Intuition

The problem does not require numeric conversion or bitwise operators.

Instead, it relies on a simple observation:

* Same characters produce `0`
* Different characters produce `1`

By iterating through both strings simultaneously and modifying one of them, the result can be built efficiently in place.

## Algorithm Steps

* Read two binary strings `a` and `b`
* Traverse the strings from left to right
* For each index:

  * If `a[i]` equals `b[i]`, replace `a[i]` with `'0'`
  * Otherwise, replace `a[i]` with `'1'`
* Output the modified string `a`

## Visual Walkthrough

### Case 1

Input

```
a = 1010
b = 0011
```

Comparison

```
Index 0: 1 vs 0 → 1
Index 1: 0 vs 0 → 0
Index 2: 1 vs 1 → 0
Index 3: 0 vs 1 → 1
```

Result

```
1001
```

---

### Case 2

Input

```
a = 111
b = 111
```

Comparison

```
All positions equal
```

Result

```
000
```

---

### Case 3

Input

```
a = 0101
b = 1010
```

Comparison

```
All positions different
```

Result

```
1111
```

## Complexity Analysis

### Time Complexity

**O(n)**

Each character of the string is processed exactly once, where `n` is the length of the string.

### Space Complexity

**O(1)**

The result is generated by modifying one of the input strings in place. No extra memory proportional to input size is used.

## Solution Explanation

The solution performs a direct character-by-character comparison of the two input strings.

Instead of creating a new string, the first string is reused to store the result, making the solution space-efficient.

This method mirrors the behavior of the XOR operation while keeping the logic simple and readable.

## Full Solution

### C++ Implementation

```cpp
#include <iostream>
using namespace std;

int main() {

    // Two binary strings of equal length
    string a, b;

    // Read the binary strings
    cin >> a >> b;

    // Traverse each character of the strings
    for (int i = 0; i < a.length(); i++) {

        // If both characters are the same,
        // the result at this position is '0'
        if (a[i] == b[i]) {
            a[i] = '0';
        }
        // If the characters are different,
        // the result at this position is '1'
        else {
            a[i] = '1';
        }
    }

    // Output the resulting binary string
    cout << a << endl;

    return 0;
}
```

## Test Cases Analysis

| Input `a` | Input `b` | Result |
| --------- | --------- | ------ |
| 1010      | 0011      | 1001   |
| 1111      | 1111      | 0000   |
| 0000      | 1111      | 1111   |
| 0101      | 0101      | 0000   |

## Edge Cases to Consider

* Minimum length strings
* All digits identical
* All digits opposite
* Large string length with mixed values

## Common Test Cases

* Same binary strings
* Complementary binary strings
* Random mixed binary patterns

## Common Mistakes to Avoid

* Converting strings to integers unnecessarily
* Forgetting that strings are guaranteed to be the same length
* Printing intermediate results instead of the final string

## Interview Relevance

* Demonstrates understanding of XOR logic
* Tests string manipulation skills
* Common beginner problem for logical reasoning

## What This Problem Teaches

* Translating bitwise concepts into string logic
* Efficient in-place string modification
* Clean iteration over fixed-size input

## Key Takeaways

* XOR behavior can be simulated without bitwise operators
* Simple logic often leads to the cleanest solutions
* String traversal is a fundamental competitive programming skill

## Problem Difficulty Analysis

This is an **Easy-level** problem.

It focuses on logical comparison and string handling rather than complex algorithms, making it ideal for beginners and interview warm-up practice.